// Autogenerated from Pigeon (v10.1.3), do not edit directly.
// See also: https://pub.dev/packages/pigeon
package com.ducdd.overlay_windows_plugin

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Placement of overlay within the screen. */
enum class OverlayAlignment(val raw: Int) {
  TOPLEFT(0),
  TOPCENTER(1),
  TOPRIGHT(2),
  CENTERLEFT(3),
  CENTER(4),
  CENTERRIGHT(5),
  BOTTOMLEFT(6),
  BOTTOMCENTER(7),
  BOTTOMRIGHT(8);

  companion object {
    fun ofRaw(raw: Int): OverlayAlignment? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Type of dragging behavior for the overlay. */
enum class PositionGravity(val raw: Int) {
  /** The `PositionGravity.none` will allow the overlay to postioned anywhere on the screen. */
  NONE(0),
  /** The `PositionGravity.right` will allow the overlay to stick on the right side of the screen. */
  RIGHT(1),
  /** The `PositionGravity.left` will allow the overlay to stick on the left side of the screen. */
  LEFT(2),
  /** The `PositionGravity.auto` will allow the overlay to stick either on the left or right side of the screen depending on the overlay position. */
  AUTO(3);

  companion object {
    fun ofRaw(raw: Int): PositionGravity? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class OverlayFlag(val raw: Int) {
  /**
   * Window flag: this window can never receive touch events.
   * Usefull if you want to display click-through overlay
   */
  CLICKTHROUGH(0),
  /**
   * Window flag: this window won't ever get key input focus
   * so the user can not send key or other button events to it.
   */
  DEFAULTFLAG(1),
  /**
   * Window flag: allow any pointer events outside of the window to be sent to the windows behind it.
   * Usefull when you want to use fields that show keyboards.
   */
  FOCUSPOINTER(2);

  companion object {
    fun ofRaw(raw: Int): OverlayFlag? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The level of detail displayed in notifications on the lock screen. */
enum class NotificationVisibility(val raw: Int) {
  /** Show this notification in its entirety on all lockscreens. */
  VISIBILITYPUBLIC(0),
  /** Do not reveal any part of this notification on a secure lockscreen. */
  VISIBILITYSECRET(1),
  /** Show this notification on all lockscreens, but conceal sensitive or private information on secure lockscreens. */
  VISIBILITYPRIVATE(2);

  companion object {
    fun ofRaw(raw: Int): NotificationVisibility? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class OverlayWindowConfig (
  val height: Long? = null,
  val width: Long? = null,
  val alignment: OverlayAlignment? = null,
  val visibility: NotificationVisibility? = null,
  val flag: OverlayFlag? = null,
  val overlayTitle: String? = null,
  val overlayContent: String? = null,
  val enableDrag: Boolean? = null,
  val positionGravity: PositionGravity? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): OverlayWindowConfig {
      val height = list[0].let { if (it is Int) it.toLong() else it as Long? }
      val width = list[1].let { if (it is Int) it.toLong() else it as Long? }
      val alignment: OverlayAlignment? = (list[2] as Int?)?.let {
        OverlayAlignment.ofRaw(it)
      }
      val visibility: NotificationVisibility? = (list[3] as Int?)?.let {
        NotificationVisibility.ofRaw(it)
      }
      val flag: OverlayFlag? = (list[4] as Int?)?.let {
        OverlayFlag.ofRaw(it)
      }
      val overlayTitle = list[5] as String?
      val overlayContent = list[6] as String?
      val enableDrag = list[7] as Boolean?
      val positionGravity: PositionGravity? = (list[8] as Int?)?.let {
        PositionGravity.ofRaw(it)
      }
      return OverlayWindowConfig(height, width, alignment, visibility, flag, overlayTitle, overlayContent, enableDrag, positionGravity)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      height,
      width,
      alignment?.raw,
      visibility?.raw,
      flag?.raw,
      overlayTitle,
      overlayContent,
      enableDrag,
      positionGravity?.raw,
    )
  }
}
@Suppress("UNCHECKED_CAST")
private object OverlayWindowApiCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          OverlayWindowConfig.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is OverlayWindowConfig -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface OverlayWindowApi {
  fun isPermissionGranted(): Boolean
  fun requestPermission()
  fun showOverlayWindows(overlayWindowId: String, entryPointName: String, config: OverlayWindowConfig)
  fun closeOverlayWindows(overlayWindowId: String)
  fun isActive(overlayWindowId: String): Boolean
  fun updateShow(overlayWindowId: String, isShow: Boolean)
  fun isShow(overlayWindowId: String): Boolean
  fun setFlags(overlayWindowId: String, flag: OverlayFlag)
  fun resize(overlayWindowId: String, width: Long, height: Long)

  companion object {
    /** The codec used by OverlayWindowApi. */
    val codec: MessageCodec<Any?> by lazy {
      OverlayWindowApiCodec
    }
    /** Sets up an instance of `OverlayWindowApi` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: OverlayWindowApi?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.OverlayWindowApi.isPermissionGranted", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isPermissionGranted())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.OverlayWindowApi.requestPermission", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.requestPermission()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.OverlayWindowApi.showOverlayWindows", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val overlayWindowIdArg = args[0] as String
            val entryPointNameArg = args[1] as String
            val configArg = args[2] as OverlayWindowConfig
            var wrapped: List<Any?>
            try {
              api.showOverlayWindows(overlayWindowIdArg, entryPointNameArg, configArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.OverlayWindowApi.closeOverlayWindows", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val overlayWindowIdArg = args[0] as String
            var wrapped: List<Any?>
            try {
              api.closeOverlayWindows(overlayWindowIdArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.OverlayWindowApi.isActive", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val overlayWindowIdArg = args[0] as String
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isActive(overlayWindowIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.OverlayWindowApi.setFlags", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val overlayWindowIdArg = args[0] as String
            val flagArg = OverlayFlag.ofRaw(args[1] as Int)!!
            var wrapped: List<Any?>
            try {
              api.setFlags(overlayWindowIdArg, flagArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.OverlayWindowApi.resize", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val overlayWindowIdArg = args[0] as String
            val widthArg = args[1].let { if (it is Int) it.toLong() else it as Long }
            val heightArg = args[2].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.resize(overlayWindowIdArg, widthArg, heightArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.OverlayWindowApi.updateShow", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val overlayWindowIdArg = args[0] as String
            val isShowArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.updateShow(overlayWindowIdArg, isShowArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.OverlayWindowApi.isShow", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val overlayWindowIdArg = args[0] as String
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isShow(overlayWindowIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
