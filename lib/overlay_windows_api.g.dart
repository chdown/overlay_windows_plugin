// Autogenerated from Pigeon (v10.1.3), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

/// Placement of overlay within the screen.
enum OverlayAlignment {
  topLeft,
  topCenter,
  topRight,
  centerLeft,
  center,
  centerRight,
  bottomLeft,
  bottomCenter,
  bottomRight,
}

/// Type of dragging behavior for the overlay.
enum PositionGravity {
  /// The `PositionGravity.none` will allow the overlay to postioned anywhere on the screen.
  none,

  /// The `PositionGravity.right` will allow the overlay to stick on the right side of the screen.
  right,

  /// The `PositionGravity.left` will allow the overlay to stick on the left side of the screen.
  left,

  /// The `PositionGravity.auto` will allow the overlay to stick either on the left or right side of the screen depending on the overlay position.
  auto,
}

enum OverlayFlag {
  /// Window flag: this window can never receive touch events.
  /// Usefull if you want to display click-through overlay
  clickThrough,

  /// Window flag: this window won't ever get key input focus
  /// so the user can not send key or other button events to it.
  defaultFlag,

  /// Window flag: allow any pointer events outside of the window to be sent to the windows behind it.
  /// Usefull when you want to use fields that show keyboards.
  focusPointer,
}

/// The level of detail displayed in notifications on the lock screen.
enum NotificationVisibility {
  /// Show this notification in its entirety on all lockscreens.
  visibilityPublic,

  /// Do not reveal any part of this notification on a secure lockscreen.
  visibilitySecret,

  /// Show this notification on all lockscreens, but conceal sensitive or private information on secure lockscreens.
  visibilityPrivate,
}

class OverlayWindowConfig {
  OverlayWindowConfig({
    this.height,
    this.width,
    this.alignment,
    this.visibility,
    this.flag,
    this.overlayTitle,
    this.overlayContent,
    this.enableDrag,
    this.positionGravity,
  });

  int? height;

  int? width;

  OverlayAlignment? alignment;

  NotificationVisibility? visibility;

  OverlayFlag? flag;

  String? overlayTitle;

  String? overlayContent;

  bool? enableDrag;

  PositionGravity? positionGravity;

  Object encode() {
    return <Object?>[
      height,
      width,
      alignment?.index,
      visibility?.index,
      flag?.index,
      overlayTitle,
      overlayContent,
      enableDrag,
      positionGravity?.index,
    ];
  }

  static OverlayWindowConfig decode(Object result) {
    result as List<Object?>;
    return OverlayWindowConfig(
      height: result[0] as int?,
      width: result[1] as int?,
      alignment: result[2] != null ? OverlayAlignment.values[result[2]! as int] : null,
      visibility: result[3] != null ? NotificationVisibility.values[result[3]! as int] : null,
      flag: result[4] != null ? OverlayFlag.values[result[4]! as int] : null,
      overlayTitle: result[5] as String?,
      overlayContent: result[6] as String?,
      enableDrag: result[7] as bool?,
      positionGravity: result[8] != null ? PositionGravity.values[result[8]! as int] : null,
    );
  }
}

class _OverlayWindowApiCodec extends StandardMessageCodec {
  const _OverlayWindowApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is OverlayWindowConfig) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return OverlayWindowConfig.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class OverlayWindowApi {
  /// Constructor for [OverlayWindowApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  OverlayWindowApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _OverlayWindowApiCodec();

  Future<bool> isPermissionGranted() async {
    final BasicMessageChannel<Object?> channel =
        BasicMessageChannel<Object?>('dev.flutter.pigeon.OverlayWindowApi.isPermissionGranted', codec, binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList = await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<void> requestPermission() async {
    final BasicMessageChannel<Object?> channel =
        BasicMessageChannel<Object?>('dev.flutter.pigeon.OverlayWindowApi.requestPermission', codec, binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList = await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> showOverlayWindows(String arg_overlayWindowId, String arg_entryPointName, OverlayWindowConfig arg_config) async {
    final BasicMessageChannel<Object?> channel =
        BasicMessageChannel<Object?>('dev.flutter.pigeon.OverlayWindowApi.showOverlayWindows', codec, binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList = await channel.send(<Object?>[arg_overlayWindowId, arg_entryPointName, arg_config]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> closeOverlayWindows(String arg_overlayWindowId) async {
    final BasicMessageChannel<Object?> channel =
        BasicMessageChannel<Object?>('dev.flutter.pigeon.OverlayWindowApi.closeOverlayWindows', codec, binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList = await channel.send(<Object?>[arg_overlayWindowId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> isActive(String arg_overlayWindowId) async {
    final BasicMessageChannel<Object?> channel =
        BasicMessageChannel<Object?>('dev.flutter.pigeon.OverlayWindowApi.isActive', codec, binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList = await channel.send(<Object?>[arg_overlayWindowId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<void> setFlags(String arg_overlayWindowId, OverlayFlag arg_flag) async {
    final BasicMessageChannel<Object?> channel =
        BasicMessageChannel<Object?>('dev.flutter.pigeon.OverlayWindowApi.setFlags', codec, binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList = await channel.send(<Object?>[arg_overlayWindowId, arg_flag.index]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> resize(String arg_overlayWindowId, int arg_width, int arg_height) async {
    final BasicMessageChannel<Object?> channel =
        BasicMessageChannel<Object?>('dev.flutter.pigeon.OverlayWindowApi.resize', codec, binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList = await channel.send(<Object?>[arg_overlayWindowId, arg_width, arg_height]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}
